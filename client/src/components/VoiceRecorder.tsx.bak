import { PanelRight } from 'lucide-react';
import React, { useState, useCallback, useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { 
  Mic, MicOff, Loader2, Download, Save, ImageIcon, Link as LinkIcon, Youtube, FileText, X, Moon, Sun,
  Bold, Italic, Underline, AlignLeft, AlignCenter, AlignRight, Search, ArrowRight, ArrowLeft
} from "lucide-react";
import { useTheme } from "@/components/theme-provider";
import { jsPDF } from "jspdf";
import { Goal } from "@shared/schema";
import { useQuery, useQueryClient, useMutation } from "@tanstack/react-query";
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { GoalsDropdown } from "@/components/GoalsDropdown";
import { format } from "date-fns";
import DOMPurify from 'dompurify'; // Added DOMPurify import

// Define SpeechRecognition types
declare global {
  interface Window {
    SpeechRecognition: any;
    webkitSpeechRecognition: any;
  }
}

interface VoiceRecorderProps {
  onTranscription: (text: string, goalId?: number) => void;
}

export function VoiceRecorder({ onTranscription }: VoiceRecorderProps) {
  const queryClient = useQueryClient();
  const { theme, setTheme } = useTheme();
  const [isRecording, setIsRecording] = useState(false);
  const [recognition, setRecognition] = useState<any>(null);
  const [selectedGoalId, setSelectedGoalId] = useState<string>();
  const [currentText, setCurrentText] = useState("");
  const [hasUnsavedRecording, setHasUnsavedRecording] = useState(false);
  const editorRef = useRef<HTMLDivElement>(null);
  const [previewUrl, setPreviewUrl] = useState<string | null>(null);
  const [previewType, setPreviewType] = useState<'image' | 'document' | null>(null);
  const [previewTitle, setPreviewTitle] = useState<string>('');
  const [searchQuery, setSearchQuery] = useState("");
  const [searchMatches, setSearchMatches] = useState<number[]>([]);
  const [currentMatchIndex, setCurrentMatchIndex] = useState(-1);
  const [entryDate, setEntryDate] = useState<Date | null>(null);

  // Add click handler for existing preview elements and load saved content
  useEffect(() => {
    if (!editorRef.current) return;

    try {
      // Load saved content from localStorage
      const savedContent = localStorage.getItem('editorContent');
      const savedGoalId = localStorage.getItem('selectedGoalId');
      const savedEntryDate = localStorage.getItem('entryDate');

      if (savedContent) {
        editorRef.current.innerHTML = savedContent;
        if (savedGoalId) {
          setSelectedGoalId(savedGoalId);
        }
        if (savedEntryDate) {
          setEntryDate(new Date(savedEntryDate));
        }
      }
    } catch (error) {
      console.error('Error loading from localStorage:', error);
      // Continue without setting content if localStorage fails
    }

    const handleEditorClick = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      const previewElement = target.closest('[data-preview]');
      if (previewElement instanceof HTMLElement) {
        e.preventDefault();
        e.stopPropagation();
        setPreviewUrl(previewElement.dataset.url || null);
        setPreviewType((previewElement.dataset.type as 'image' | 'document') || null);
        setPreviewTitle(previewElement.dataset.title || '');
      }
    };

    editorRef.current.addEventListener('click', handleEditorClick);
    return () => {
      editorRef.current?.removeEventListener('click', handleEditorClick);
    };
  }, []);

  // Save editor content to localStorage whenever it changes
  useEffect(() => {
    if (!editorRef.current) return;

    const saveEditorContent = () => {
      try {
        const content = editorRef.current?.innerHTML || '';
        localStorage.setItem('editorContent', content);
        if (selectedGoalId) {
          localStorage.setItem('selectedGoalId', selectedGoalId);
        }
        
        // Check if content is over 50 characters
        const plainText = editorRef.current?.textContent || '';
        if (plainText.length > 50) {
          const currentDate = new Date();
          // Always update the date when content changes and is over 50 chars
          setEntryDate(currentDate);
          
          // Save the entry date to localStorage
          localStorage.setItem('entryDate', currentDate.toISOString());
          
          // Add this entry to the journal entries for date-based filtering
          try {
            const journalEntries = JSON.parse(localStorage.getItem('journalEntries') || '[]');
            
            // Define journal entry interface
            interface JournalEntry {
              goalId: string | undefined;
              text: string;
              date: string;
            }
            
            // Check if we need to update an existing entry or add a new one
            const existingEntryIndex = journalEntries.findIndex(
              (entry: JournalEntry) => entry.goalId === selectedGoalId && entry.text === plainText
            );
            
            if (existingEntryIndex >= 0) {
              // Update existing entry with new date
              journalEntries[existingEntryIndex].date = currentDate.toISOString();
            } else {
              // Add new entry
              journalEntries.push({
                goalId: selectedGoalId,
                text: plainText,
                date: currentDate.toISOString()
              });
            }
            
            localStorage.setItem('journalEntries', JSON.stringify(journalEntries));
            console.log('Journal entry saved for date filtering');
          } catch (error) {
            console.error('Error saving journal entry:', error);
          }
        }
      } catch (error) {
        console.error('Error saving to localStorage:', error);
        // Continue without saving if localStorage fails
      }
    };

    // Add event listeners to detect content changes
    editorRef.current.addEventListener('input', saveEditorContent);
    editorRef.current.addEventListener('paste', saveEditorContent);

    return () => {
      if (editorRef.current) {
        editorRef.current.removeEventListener('input', saveEditorContent);
        editorRef.current.removeEventListener('paste', saveEditorContent);
      }
    };
  }, [selectedGoalId, entryDate]);

  // State for goal selection
  const [selectedMainGoal, setSelectedMainGoal] = useState<Goal | null>(null);
  const [selectedSubGoal, setSelectedSubGoal] = useState<Goal | null>(null);

  const { data: goals } = useQuery<Goal[]>({
  });

  // Select a goal from the dropdown
  const handleGoalSelect = (goal: Goal) => {
    if (selectedGoalId === goal.id.toString()) return;

    if (hasUnsavedRecording && !confirm('You have unsaved changes. Switch goal anyway?')) return;

    setSelectedMainGoal(goal);
    setSelectedSubGoal(null);
    setSelectedGoalId(goal.id.toString());

    if (editorRef.current) {
      editorRef.current.innerHTML = goal.description || '';
      // Save the content to localStorage for persistence
      try {
        localStorage.setItem('editorContent', goal.description || '');
        localStorage.setItem('selectedGoalId', goal.id.toString());
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
      setHasUnsavedRecording(false);
    }
  };

  // Select a sub-goal from the side panel
  const handleSubGoalSelect = (goal: Goal) => {
    if (selectedGoalId === goal.id.toString()) return;

    if (hasUnsavedRecording && !confirm('You have unsaved changes. Switch to this sub-goal anyway?')) return;

    setSelectedSubGoal(goal);
    setSelectedGoalId(goal.id.toString());

    // Set sub-goal content in the editor
    if (editorRef.current) {
      editorRef.current.innerHTML = goal.description || '';
      // Save to localStorage for persistence
      try {
        localStorage.setItem('editorContent', goal.description || '');
        localStorage.setItem('selectedGoalId', goal.id.toString());
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
      setHasUnsavedRecording(false);
    }
  };

  // Handle description click from dropdown side panel
  const handleDescriptionClick = (content: string) => {
    if (hasUnsavedRecording && !confirm('You have unsaved changes. Load this content anyway?')) return;

    if (editorRef.current) {
      editorRef.current.innerHTML = content;
      // Save to localStorage for persistence
      try {
        localStorage.setItem('editorContent', content);
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }
      setHasUnsavedRecording(false);
    }
  };

  // Format text in editor
  const formatText = useCallback((command: string, value?: string) => {
    document.execCommand(command, false, value);
    if (editorRef.current) {
      setHasUnsavedRecording(true);
    }
  }, []);

  // Search functionality
  const handleSearch = useCallback(() => {
    if (!editorRef.current || !searchQuery) return;

    // Remove existing highlights
    const text = editorRef.current.innerHTML;
    editorRef.current.innerHTML = text.replace(/<mark class="search-highlight">/g, '')
      .replace(/<mark class="search-highlight current">/g, '')
      .replace(/<\/mark>/g, '');

    if (!searchQuery.trim()) {
      setSearchMatches([]);
      setCurrentMatchIndex(-1);
      return;
    }

    const content = editorRef.current.textContent || '';
    const matches: number[] = [];
    let pos = content.toLowerCase().indexOf(searchQuery.toLowerCase());

    while (pos !== -1) {
      matches.push(pos);
      pos = content.toLowerCase().indexOf(searchQuery.toLowerCase(), pos + 1);
    }

    if (matches.length > 0) {
      let newHtml = content;
      for (let i = matches.length - 1; i >= 0; i--) {
        const start = matches[i];
        const end = start + searchQuery.length;
        const before = newHtml.substring(0, start);
        const match = newHtml.substring(start, end);
        const after = newHtml.substring(end);
        newHtml = `${before}<mark class="search-highlight">${match}</mark>${after}`;
      }
      editorRef.current.innerHTML = newHtml;
      setSearchMatches(matches);
      setCurrentMatchIndex(0);
    }
  }, [searchQuery]);

  // Navigate between search matches
  const navigateSearch = useCallback((direction: 'next' | 'prev') => {
    if (searchMatches.length === 0) return;

    const marks = editorRef.current?.getElementsByClassName('search-highlight');
    if (!marks) return;

    // Remove current highlight
    const currentMark = editorRef.current?.querySelector('.search-highlight.current');
    if (currentMark) {
      currentMark.classList.remove('current');
    }

    // Update current match index
    let newIndex = currentMatchIndex;
    if (direction === 'next') {
      newIndex = (currentMatchIndex + 1) % searchMatches.length;
    } else {
      newIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
    }

    // Add highlight to new current match
    marks[newIndex].classList.add('current');
    marks[newIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
    setCurrentMatchIndex(newIndex);
  }, [searchMatches, currentMatchIndex]);

  useEffect(() => {
        e.preventDefault();
        const searchInput = document.querySelector<HTMLInputElement>('input[placeholder="Search in text..."]');
        if (searchInput) {
          searchInput.focus();
        }
      }
    };

  }, []);

  // Download PDF
  const downloadPDF = useCallback(() => {
    if (!editorRef.current) return;

    const doc = new jsPDF();
    const content = editorRef.current.innerText;
    const textLines = doc.splitTextToSize(content, 170);

    doc.setFontSize(12);
    if (selectedGoalId && goals) {
      const goal = goals.find(g => g.id.toString() === selectedGoalId);
      if (goal) {
        doc.setFontSize(16);
        doc.text(goal.title, 20, 20);
        doc.setFontSize(12);
        doc.text(textLines, 20, 40);
      } else {
        doc.text(textLines, 20, 20);
      }
    } else {
      doc.text(textLines, 20, 20);
    }

    doc.save(`transcript-${format(new Date(), 'yyyy-MM-dd-HH-mm')}.pdf`);
  }, [selectedGoalId, goals]);

  const handleFileSelect = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file || !editorRef.current) return;

    const formData = new FormData();
    formData.append('file', file);

    try {
      const response = await fetch('/api/upload', {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) throw new Error('Upload failed');

      const data = await response.json();
      const timestamp = format(new Date(), 'PPP');

      // Create an inline wrapper for the media (using span for inline display)
      const wrapper = document.createElement('span');
      wrapper.className = 'inline-block align-middle media-wrapper';
      wrapper.contentEditable = 'false';
      
      if (file.type.startsWith('image/')) {
        wrapper.innerHTML = `
          <span class="media-wrapper" contenteditable="false" style="display: inline-block; vertical-align: middle; margin: 0 4px;">
            <span 
              class="group cursor-pointer transition-all hover:opacity-90 relative" 
              data-preview 
              data-url="${data.url}" 
              data-type="image" 
              data-title="${file.name}"
            >
              <button 
                class="absolute -right-2 -top-2 bg-red-500 hover:bg-red-600 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity z-10"
                onclick="(function(e) {
                  e.stopPropagation();
                  e.currentTarget.closest('.media-wrapper').remove();
                  document.dispatchEvent(new CustomEvent('contentChanged'));
                })(event)"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
              </button>
              <img 
                src="${data.url}"
                alt="${file.name}"
                class="max-w-[200px] max-h-[200px] rounded-lg object-contain"
              />
              <div class="text-xs text-center mt-1 text-gray-500 pointer-events-none">
                <div class="file-name">${file.name}</div>
                <div class="text-xs text-gray-400">${timestamp}</div>
              </div>
            </span>
          </span>
        `.trim();
      } else {
        const icon = file.type === 'application/pdf' ? 'üìÑ' : 
                    file.type.includes('word') ? 'üìù' : 'üì∞';

        wrapper.innerHTML = `
          <span class="media-wrapper" contenteditable="false" style="display: inline-block; vertical-align: middle; margin: 0 4px;">
            <span 
              class="group cursor-pointer relative" 
              data-preview 
              data-url="${data.url}" 
              data-type="document" 
              data-title="${file.name}"
            >
              <button 
                class="absolute -right-2 -top-2 bg-red-500 hover:bg-red-600 text-white rounded-full p-1 opacity-0 group-hover:opacity-100 transition-opacity z-10"
                onclick="(function(e) {
                  e.stopPropagation();
                  e.currentTarget.closest('.media-wrapper').remove();
                  document.dispatchEvent(new CustomEvent('contentChanged'));
                })(event)"
              >
                <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
              </button>
              <div class="flex items-center gap-2 p-2 border rounded hover:bg-gray-100 transition-colors">
                <span class="text-2xl">${icon}</span>
                <div>
                  <div class="text-sm font-medium group-hover:text-primary transition-colors file-name">
                    ${file.name}
                  </div>
                  <div class="text-xs text-gray-500">
                    ${Math.round(file.size / 1024)} KB
                    <div class="text-xs text-gray-400">${timestamp}</div>
                  </div>
                </div>
              </div>
            </span>
          </span>
        `.trim();
      }

      // Get the current selection (cursor position)
      const selection = window.getSelection();
      
      if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        
        // Check if selection is within our editor
        if (editorRef.current.contains(range.commonAncestorContainer)) {
          // Focus the editor to ensure proper insertion
          editorRef.current.focus();
          
          // Ensure we insert at exact cursor position by collapsing range if needed
          if (!range.collapsed) {
            range.collapse(true);
          }
          
          // Insert the media at cursor position
          range.insertNode(wrapper);
          
          // Move cursor after the inserted media
          const newRange = document.createRange();
          newRange.setStartAfter(wrapper);
          newRange.setEndAfter(wrapper);
          selection.removeAllRanges();
          selection.addRange(newRange);
          
          // Insert a non-breaking space after the media to make typing easier
          const space = document.createTextNode('\u00A0');
          newRange.insertNode(space);
          newRange.setStartAfter(space);
          newRange.setEndAfter(space);
          selection.removeAllRanges();
          selection.addRange(newRange);
        } else {
          // If selection is outside the editor, append to end of editor
          editorRef.current.appendChild(wrapper);
          editorRef.current.appendChild(document.createTextNode('\u00A0'));
          editorRef.current.focus();
        }
      } else {
        // No selection at all, append to end
        editorRef.current.appendChild(wrapper);
        editorRef.current.appendChild(document.createTextNode('\u00A0'));
        editorRef.current.focus();
      }

      // Add click handler to the preview element
      const previewElement = wrapper.querySelector('[data-preview]');
      if (previewElement) {
        previewElement.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const target = e.currentTarget as HTMLElement;
          setPreviewUrl(target.dataset.url || null);
          setPreviewType((target.dataset.type as 'image' | 'document') || null);
          setPreviewTitle(target.dataset.title || '');
        });
      }

      setHasUnsavedRecording(true);
    } catch (error) {
      console.error('Error uploading file:', error);
    }

    // Reset file input
    e.target.value = '';
  }, []);

  const startRecording = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      stream.getTracks().forEach(track => track.stop()); // Release the stream immediately
      setMicrophoneStatus('ready');

      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        alert("Speech recognition is not supported in this browser. Please use Chrome or Edge.");
        return;
      }
    } catch (err: any) {
      setMicrophoneStatus(err.name === 'NotAllowedError' ? 'denied' : 'error');
      alert("Microphone access is required. Please check your browser settings.");
      return;
    }
    try {
      const SpeechRecognitionAPI = window.SpeechRecognition || window.webkitSpeechRecognition;
      const recognition = new SpeechRecognitionAPI();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = 'en-US';
      recognition.onstart = () => setIsRecording(true);
      recognition.onresult = (event: any) => {
        let finalTranscript = '';
        let interimTranscript = '';
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const transcript = event.results[i][0].transcript;
          if (event.results[i].isFinal) finalTranscript += transcript;
          else interimTranscript += transcript;
        }
        setCurrentText(prev => {
          const cleanPrev = prev.replace(/\[Speaking\.\.\.\] .*$/, '');
          const space = cleanPrev && !cleanPrev.endsWith(' ') ? ' ' : '';
          let newText = cleanPrev;
          if (finalTranscript) {
            newText += space + finalTranscript;
            setHasUnsavedRecording(true);
          }
          if (interimTranscript) newText += space + '[Speaking...] ' + interimTranscript;
          return newText;
        });
      };
      recognition.onerror = (event: any) => {
        console.error("Speech recognition error", event.error);
        setIsRecording(false);
      };
      recognition.onend = () => setIsRecording(false);
      recognition.start();
      setRecognition(recognition);
    } catch (error) {
      console.error("Error starting speech recognition:", error);
      alert("Failed to start speech recognition. Please try again.");
      setIsRecording(false);
    }
  }, []);

  const stopRecording = useCallback(() => {
    if (recognition) {
      recognition.stop();
      setRecognition(null);
    }
    setIsRecording(false);
  }, [recognition]);

  const updateGoalMutation = useMutation({
    mutationFn: (updatedGoal: Partial<Goal>) => 
      fetch(`/api/goals/${updatedGoal.id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updatedGoal)
      }).then(res => res.json()),
    onSuccess: () => {
      setHasUnsavedRecording(false);
    }
  });

  const saveRecording = useCallback(() => {
    if (editorRef.current && hasUnsavedRecording && selectedGoalId) {
      const sanitizeHTML = (html: string) => {
        return html.replace(/<script.*?>.*?<\/script>/gi, '');
      };
      const cleanHTML = sanitizeHTML(editorRef.current.innerHTML);
      const plainText = editorRef.current.textContent || '';

      // Save to localStorage to persist across page navigations
      try {
        localStorage.setItem('editorContent', cleanHTML);
        
        // If text length is >= 50 characters, ensure we have a journal entry
        if (plainText.length >= 50) {
          // Add or update journal entry with the current date
          const currentDate = entryDate || new Date();
          
          // Update journal entries
          const journalEntries = JSON.parse(localStorage.getItem('journalEntries') || '[]');
          
          // Check if an entry with this goalId and date exists already
          const existingEntryIndex = journalEntries.findIndex((entry: any) => 
            entry.goalId === selectedGoalId && 
            new Date(entry.date).toDateString() === currentDate.toDateString());
          
          if (existingEntryIndex >= 0) {
            // Update existing entry
            journalEntries[existingEntryIndex].text = plainText;
          } else {
            // Add new entry
            journalEntries.push({
              goalId: selectedGoalId,
              text: plainText,
              date: currentDate.toISOString()
            });
          }
          
          localStorage.setItem('journalEntries', JSON.stringify(journalEntries));
          console.log('Journal entry saved for date filtering');
        }
      } catch (error) {
        console.error('Error saving to localStorage:', error);
      }

      updateGoalMutation.mutate({
        id: parseInt(selectedGoalId),
        description: cleanHTML
      });
    }
  }, [selectedGoalId, hasUnsavedRecording, entryDate]);

  const [showLinkDialog, setShowLinkDialog] = useState(false);
  const [linkType, setLinkType] = useState<'youtube' | 'website'>('website');
  const [linkUrl, setLinkUrl] = useState('');
  const [linkTitle, setLinkTitle] = useState('');

  const handleAddLink = useCallback((type: 'youtube' | 'website') => {
    setLinkType(type);
    setLinkUrl('');
    setLinkTitle('');
    setShowLinkDialog(true);
  }, []);

  const insertLink = useCallback(() => {
    if (!linkUrl) return;
    
    const currentDate = new Date().toLocaleDateString();
    const lastDate = currentText.match(/\[Date: ([^\]]+)\]/)?.[1];
    const prefix = !lastDate || lastDate !== currentDate ? `\n[Date: ${currentDate}]\n` : '';
    
    let linkText;
    if (linkType === 'youtube') {
      linkText = `\n[YouTube: ${linkUrl}](${linkUrl})\n`;
    } else {
      linkText = `\n[Website: ${linkTitle || linkUrl}](${linkUrl})\n`;
    }

    if (editorRef.current) {
      // Insert at cursor position or append to end
      const selection = window.getSelection();
      if (selection && selection.rangeCount > 0 && selection.getRangeAt(0).commonAncestorContainer.contains(editorRef.current)) {
        const range = selection.getRangeAt(0);
        const textNode = document.createTextNode(prefix + linkText);
        range.insertNode(textNode);
        range.setStartAfter(textNode);
        range.setEndAfter(textNode);
        selection.removeAllRanges();
        selection.addRange(range);
      } else {
        editorRef.current.innerHTML += prefix + linkText;
      }
    }

    setCurrentText(prev => prev + prefix + linkText);
    setHasUnsavedRecording(true);
    setShowLinkDialog(false);
  }, [currentText, linkType, linkUrl, linkTitle]);

  const [microphoneStatus, setMicrophoneStatus] = useState<'ready' | 'error' | 'denied'>('ready');

  useEffect(() => {
    if (!editorRef.current) return;

    const handleContentChanged = () => {
      setHasUnsavedRecording(true);
    };

    document.addEventListener('contentChanged', handleContentChanged);

    const handleEditorClick = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      const previewElement = target.closest('[data-preview]');
      if (previewElement instanceof HTMLElement) {
        e.preventDefault();
        e.stopPropagation();
        setPreviewUrl(previewElement.dataset.url || null);
        setPreviewType((previewElement.dataset.type as 'image' | 'document') || null);
        setPreviewTitle(previewElement.dataset.title || '');
      }
    };

    // Track first entry date
    const checkAndStoreFirstEntry = () => {
      if (!editorRef.current) return;
      const content = editorRef.current.textContent || '';
      if (content.length > 50) {
        const existingDates = JSON.parse(localStorage.getItem('firstEntryDates') || '[]');
        const today = format(new Date(), 'yyyy-MM-dd');
        if (!existingDates.includes(today)) {
          existingDates.push(today);
          localStorage.setItem('firstEntryDates', JSON.stringify(existingDates));
        }
      }
    };

    editorRef.current.addEventListener('input', checkAndStoreFirstEntry); // Add event listener for input
    editorRef.current.addEventListener('click', handleEditorClick);
    return () => {
      editorRef.current?.removeEventListener('click', handleEditorClick);
      editorRef.current?.removeEventListener('input', checkAndStoreFirstEntry); //remove event listener
      document.removeEventListener('contentChanged', handleContentChanged);
    };
  }, []);


  return (
    <div className={`space-y-3 p-3 rounded-lg shadow-sm border border-border ${theme === "dark" ? "bg-card/80 text-white" : "bg-card/80 text-black"} relative overflow-hidden bg-pattern w-full`}>
      {/* No decorative elements */}
      
      <div className="flex flex-wrap items-center gap-3 justify-between relative z-10">
        <div className="flex flex-wrap items-center gap-3">
          <GoalsDropdown 
            onSelectGoal={handleGoalSelect} 
            goals={goals} 
            onDescriptionClick={handleDescriptionClick} 
            onSubGoalClick={handleSubGoalSelect} 
          />
          <Button
            variant={isRecording ? "destructive" : "default"}
            onClick={isRecording ? stopRecording : startRecording}
            className={`flex items-center gap-2 relative overflow-hidden ${isRecording ? 'mic-recording' : ''}`}
          >
            {isRecording ? (
              <MicOff className="h-5 w-5" />
            ) : (
              <Mic className="h-5 w-5" />
            )}
            {isRecording ? "Stop Recording" : "Start Recording"}
          </Button>
          <Button variant="outline" asChild>
            <label htmlFor="image-upload" className="cursor-pointer flex items-center gap-2">
              <ImageIcon className="h-4 w-4" />
              Add Image
            </label>
          </Button>
          <input
            id="image-upload"
            type="file"
            accept="image/*"
            className="hidden"
            onChange={handleFileSelect}
          />
          <Button variant="outline" asChild>
            <label htmlFor="document-upload" className="cursor-pointer flex items-center gap-2">
              <FileText className="h-4 w-4" />
              Add Document
            </label>
          </Button>
          <input
            id="document-upload"
            type="file"
            accept=".pdf,.doc,.docx,.txt"
            className="hidden"
            onChange={handleFileSelect}
          />
          <Button variant="outline" onClick={() => handleAddLink('youtube')}>
            <Youtube className="h-4 w-4 mr-2" />
            Add YouTube
          </Button>
          <Button variant="outline" onClick={() => handleAddLink('website')}>
            <LinkIcon className="h-4 w-4 mr-2" />
            Add Website
          </Button>
        </div>
        <Button
          variant="ghost"
          size="icon"
          onClick={() => setTheme(theme === "dark" ? "light" : "dark")}
          className="rounded-full w-8 h-8"
        >
          {theme === "dark" ? <Sun className="h-5 w-5" /> : <Moon className="h-5 w-5" />}
        </Button>
      </div>
      {isRecording && (
        <div className="flex items-center text-red-500">
          <Loader2 className="h-4 w-4 animate-spin mr-2" />
          Recording...
        </div>
      )}
      <Dialog open={!!previewUrl} onOpenChange={() => {
        setPreviewUrl(null);
        setPreviewType(null);
        setPreviewTitle('');
      }}>
        <DialogContent className="max-w-[90vw] max-h-[90vh] w-full h-full p-4 sm:p-6">
          <DialogHeader className="flex justify-between items-center">
            <DialogTitle className="flex items-center gap-2">
              {previewType === 'document' && <FileText className="h-5 w-5" />}
              {previewType === 'image' && <ImageIcon className="h-5 w-5" />}
              {previewTitle}
            </DialogTitle>
            <Button
              variant="ghost"
              size="icon"
              onClick={() => {
                setPreviewUrl(null);
                setPreviewType(null);
                setPreviewTitle('');
              }}
              className="rounded-full"
            >
              <X className="h-4 w-4" />
            </Button>
          </DialogHeader>
          <div className="mt-4 relative overflow-auto">
            {previewType === 'image' && (
              <div className="relative group">
                <img
                  src={previewUrl || ''}
                  alt={previewTitle}
                  className="max-w-full h-auto mx-auto rounded-lg"
                />
                <div className="absolute bottom-4 right-4 flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                  <Button
                    variant="destructive"
                    onClick={() => {
                      const mediaWrapper = editorRef.current?.querySelector(`[data-url="${previewUrl}"]`)?.closest('.media-wrapper');
                      if (mediaWrapper) {
                        mediaWrapper.remove();
                        document.dispatchEvent(new CustomEvent('contentChanged'));
                        setPreviewUrl(null);
                        setPreviewType(null);
                        setPreviewTitle('');
                      }
                    }}
                    className="rounded-full h-9"
                  >
                    <X className="h-4 w-4 mr-2" />
                    Delete
                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => previewUrl && window.open(previewUrl, '_blank')}
                    className="rounded-full h-9"
                  >
                    <Download className="h-4 w-4 mr-2" />
                    Download
                  </Button>
                </div>
              </div>
            )}
            {previewType === 'document' && (
              <div className="relative h-[70vh]">
                {previewUrl?.toLowerCase().endsWith('.pdf') ? (
                  <iframe
                    src={`${previewUrl}#toolbar=0`}
                    className="w-full h-full rounded-lg border border-border"
                    title={previewTitle}
                  />
                ) : (
                  <div className="flex items-center justify-center h-full">
                    <div className="flex gap-2">
                      <Button
                        variant="destructive"
                        onClick={() => {
                          const mediaWrapper = editorRef.current?.querySelector(`[data-url="${previewUrl}"]`)?.closest('.media-wrapper');
                          if (mediaWrapper) {
                            mediaWrapper.remove();
                            document.dispatchEvent(new CustomEvent('contentChanged'));
                            setPreviewUrl(null);
                            setPreviewType(null);
                            setPreviewTitle('');
                          }
                        }}
                        className="rounded-full h-9"
                      >
                        <X className="h-4 w-4 mr-2" />
                        Delete
                      </Button>
                      <Button
                        variant="outline"
                        onClick={() => previewUrl && window.open(previewUrl, '_blank')}
                        className="rounded-full h-9"
                      >
                        <Download className="h-4 w-4 mr-2" />
                        Download Document
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>
      
      <Dialog open={showLinkDialog} onOpenChange={setShowLinkDialog}>
        <DialogContent className="sm:max-w-[425px] p-4 sm:p-6">
          <DialogHeader>
            <DialogTitle>
              {linkType === 'youtube' ? 'Add YouTube Video' : 'Add Website Link'}
            </DialogTitle>
            <DialogDescription>
              {linkType === 'youtube' 
                ? 'Enter a YouTube URL to embed a video' 
                : 'Enter website URL and title to add a link'}
            </DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="url" className="text-right">
                URL
              </Label>
              <Input 
                id="url" 
                value={linkUrl} 
                onChange={(e) => setLinkUrl(e.target.value)} 
                placeholder={linkType === 'youtube' ? 'https://www.youtube.com/watch?v=...' : 'https://example.com'} 
                className="col-span-3" 
              />
            </div>
            {linkType === 'website' && (
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="title" className="text-right">
                  Title
                </Label>
                <Input 
                  id="title" 
                  value={linkTitle} 
                  onChange={(e) => setLinkTitle(e.target.value)} 
                  placeholder="Link title" 
                  className="col-span-3" 
                />
              </div>
            )}
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setShowLinkDialog(false)} className="rounded-full h-9">Cancel</Button>
            <Button onClick={insertLink} className="rounded-full h-9">Add {linkType === 'youtube' ? 'Video' : 'Link'}</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
      
      <div className="mt-4">
        <div className="flex flex-wrap items-center gap-2 border-b pb-3 pt-1 border-border mb-3">
          <div className="flex gap-1 bg-muted/20 rounded-lg p-0.5">
            <Button variant="ghost" size="icon" onClick={() => formatText('bold')} title="Bold" className="h-8 w-8 rounded-md hover:bg-background">
              <Bold className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => formatText('italic')} title="Italic" className="h-8 w-8 rounded-md hover:bg-background">
              <Italic className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => formatText('underline')} title="Underline" className="h-8 w-8 rounded-md hover:bg-background">
              <Underline className="h-4 w-4" />
            </Button>
          </div>
          <div className="h-6 w-px bg-border mx-2" />
          <div className="flex gap-1 bg-muted/20 rounded-lg p-0.5">
            <Button variant="ghost" size="icon" onClick={() => formatText('justifyLeft')} title="Align Left" className="h-8 w-8 rounded-md hover:bg-background">
              <AlignLeft className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => formatText('justifyCenter')} title="Align Center" className="h-8 w-8 rounded-md hover:bg-background">
              <AlignCenter className="h-4 w-4" />
            </Button>
            <Button variant="ghost" size="icon" onClick={() => formatText('justifyRight')} title="Align Right" className="h-8 w-8 rounded-md hover:bg-background">
              <AlignRight className="h-4 w-4" />
            </Button>
          </div>
          <div className="h-6 w-px bg-border mx-2" />
          <div className="flex items-center gap-2 bg-muted/20 rounded-lg p-1 pl-2 flex-grow">
            <Search className="h-4 w-4 text-muted-foreground" />
            <Input
              placeholder="Search in text..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              }}
              className="w-48 bg-transparent border-none focus-visible:ring-0 focus-visible:ring-offset-0 p-0 h-7 text-sm"
            />
            {searchMatches.length > 0 && (
              <span className="text-sm px-2 py-0.5 rounded-full bg-muted/40 text-foreground">
                {currentMatchIndex + 1} of {searchMatches.length}
              </span>
            )}
            <Button 
              variant="ghost" 
              size="sm" 
              onClick={handleSearch}
              className="h-7 px-2 ml-auto mr-0"
            >
              Search
            </Button>
          </div>
        </div>
        <div>
          <div className="relative">
            <div
              ref={editorRef}
              className={`w-full min-h-[250px] p-4 border border-border rounded-lg ${theme === "dark" ? "bg-muted/30 text-foreground" : "bg-card text-foreground"} transition-colors duration-300 focus:outline-none shadow-sm`}
              contentEditable
              onInput={() => setHasUnsavedRecording(true)}
            />
          </div>
        </div>

        <div className="flex items-center justify-between mt-4">
          <div className="flex gap-3">
            <Button 
              variant="outline" 
              onClick={downloadPDF}
              className="relative overflow-hidden"
            >
              <Download className="h-4 w-4 mr-2" />
              Save PDF
            </Button>
          </div>
          <Button 
            onClick={saveRecording} 
            variant="default"
            className="relative overflow-hidden flex items-center"
            disabled={!hasUnsavedRecording}
          >
            <Save className="h-4 w-4 mr-2" />
            {hasUnsavedRecording ? 'Save Changes' : 'No Changes to Save'}
          </Button>
        </div>
      </div>
      <style>{`
        .search-highlight {
          background-color: #ffd700;
        }
        .search-highlight.current {
          background-color: #ff8c00;
        }
      `}</style>
    </div>
  );
}